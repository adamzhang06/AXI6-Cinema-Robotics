<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AXI6 Curve Editor</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg-deep: #181818;
      --bg-panel: #222222;
      --bg-toolbar: #2a2a2a;
      --bg-input: #1a1a1a;
      --border: #3a3a3a;
      --border-subtle: #2e2e2e;
      --text: #d4d4d4;
      --text-dim: #888;
      --text-muted: #555;
      --accent: #e89a3c;
      --accent-dim: rgba(232, 154, 60, 0.25);
      --curve: #5b9bd5;
      --curve-glow: rgba(91, 155, 213, 0.3);
      --handle-line: rgba(232, 154, 60, 0.5);
      --handle-dot: #e89a3c;
      --velocity: rgba(120, 200, 120, 0.5);
      --playhead: #e05050;
      --grid: rgba(255, 255, 255, 0.04);
      --grid-major: rgba(255, 255, 255, 0.08);
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Inter', -apple-system, sans-serif;
      background: var(--bg-deep);
      color: var(--text);
      height: 100vh;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      user-select: none;
    }

    /* ---- TOOLBAR ---- */
    .toolbar {
      display: flex;
      align-items: center;
      gap: 2px;
      padding: 0 12px;
      height: 38px;
      min-height: 38px;
      background: var(--bg-toolbar);
      border-bottom: 1px solid var(--border);
      font-size: 11px;
    }

    .toolbar .sep {
      width: 1px;
      height: 20px;
      background: var(--border);
      margin: 0 8px;
    }

    .toolbar label {
      color: var(--text-dim);
      font-size: 10px;
      margin-right: 3px;
      white-space: nowrap;
    }

    .toolbar input[type="number"] {
      width: 52px;
      padding: 3px 5px;
      background: var(--bg-input);
      border: 1px solid var(--border);
      border-radius: 3px;
      color: var(--text);
      font-family: inherit;
      font-size: 11px;
      margin-right: 6px;
    }

    .toolbar input[type="number"]:focus {
      outline: none;
      border-color: var(--accent);
    }

    .tb-btn {
      padding: 4px 10px;
      background: var(--bg-input);
      border: 1px solid var(--border);
      border-radius: 4px;
      color: var(--text);
      font-family: inherit;
      font-size: 11px;
      cursor: pointer;
      transition: all 0.15s;
      white-space: nowrap;
    }

    .tb-btn:hover {
      border-color: var(--text-dim);
      background: #333;
    }

    .tb-btn.play-btn {
      font-size: 13px;
      padding: 3px 8px;
      min-width: 28px;
      text-align: center;
    }

    .tb-btn.play-btn.playing {
      color: var(--playhead);
      border-color: var(--playhead);
    }

    .tb-btn.send-btn {
      background: var(--accent);
      border-color: var(--accent);
      color: #111;
      font-weight: 600;
    }

    .tb-btn.send-btn:hover {
      background: #f0a84a;
      box-shadow: 0 0 12px var(--accent-dim);
    }

    .tb-btn.send-btn:disabled {
      opacity: 0.4;
      cursor: default;
    }

    .tb-spacer {
      flex: 1;
    }

    .tb-info {
      font-size: 10px;
      color: var(--text-dim);
      font-family: 'SF Mono', 'Menlo', monospace;
      margin-right: 8px;
    }

    /* ---- CANVAS ---- */
    .canvas-wrap {
      flex: 1;
      position: relative;
      overflow: hidden;
    }

    canvas {
      display: block;
      width: 100%;
      height: 100%;
    }

    /* ---- TOAST ---- */
    .toast {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%) translateY(60px);
      padding: 8px 20px;
      background: var(--bg-toolbar);
      border: 1px solid var(--accent);
      border-radius: 6px;
      color: var(--accent);
      font-size: 12px;
      font-weight: 500;
      opacity: 0;
      transition: all 0.25s ease;
      z-index: 100;
      pointer-events: none;
    }

    .toast.error {
      border-color: var(--playhead);
      color: var(--playhead);
    }

    .toast.show {
      transform: translateX(-50%) translateY(0);
      opacity: 1;
    }

    /* ---- TOOLTIP ---- */
    .tooltip {
      position: fixed;
      padding: 4px 8px;
      background: rgba(0, 0, 0, 0.85);
      border: 1px solid var(--border);
      border-radius: 4px;
      font-size: 10px;
      color: var(--text);
      font-family: 'SF Mono', 'Menlo', monospace;
      pointer-events: none;
      z-index: 50;
      display: none;
      white-space: nowrap;
    }

    /* ---- CONTEXT MENU ---- */
    .ctx-menu {
      position: fixed;
      background: var(--bg-toolbar);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 4px 0;
      z-index: 200;
      display: none;
      min-width: 140px;
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.5);
    }

    .ctx-menu .ctx-item {
      padding: 6px 14px;
      font-size: 11px;
      color: var(--text);
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .ctx-menu .ctx-item:hover {
      background: rgba(255, 255, 255, 0.06);
    }

    .ctx-menu .ctx-item .shortcut {
      color: var(--text-muted);
      font-size: 10px;
    }

    .ctx-menu .ctx-sep {
      height: 1px;
      background: var(--border);
      margin: 3px 0;
    }
  </style>
</head>

<body>

  <!-- TOOLBAR -->
  <div class="toolbar">
    <button class="tb-btn play-btn" id="btnPlay" title="Play/Stop preview (Space)">▶</button>
    <div class="sep"></div>

    <label>Time</label><input type="number" id="inTime" value="3.0" step="0.1" min="0.1">
    <label>Angle</label><input type="number" id="inAngle" value="360" step="1" min="1">
    <label>dt</label><input type="number" id="inDt" value="0.001" step="0.001" min="0.0001">
    <label>st/rev</label><input type="number" id="inSteps" value="400" step="1" min="1">

    <div class="sep"></div>
    <button class="tb-btn" id="btnPreset">Trapezoid</button>
    <button class="tb-btn" id="btnSCurve">S-Curve</button>
    <button class="tb-btn" id="btnClear" style="color:#e05050;">Clear</button>

    <div class="tb-spacer"></div>
    <span class="tb-info" id="infoDisplay">0 pts</span>
    <div class="sep"></div>
    <button class="tb-btn send-btn" id="btnSend">▶ Send to Motor</button>
  </div>

  <!-- CANVAS -->
  <div class="canvas-wrap">
    <canvas id="cv"></canvas>
  </div>

  <!-- OVERLAYS -->
  <div class="toast" id="toast"></div>
  <div class="tooltip" id="tooltip"></div>
  <div class="ctx-menu" id="ctxMenu">
    <div class="ctx-item" data-action="smooth">Smooth <span class="shortcut">S</span></div>
    <div class="ctx-item" data-action="corner">Corner <span class="shortcut">C</span></div>
    <div class="ctx-item" data-action="auto">Auto Tangent <span class="shortcut">A</span></div>
    <div class="ctx-sep"></div>
    <div class="ctx-item" data-action="delete" style="color:#e05050;">Delete Point <span class="shortcut">⌫</span></div>
  </div>

  <script>
    (() => {
      // =================================================================
      //  STATE
      // =================================================================
      const cv = document.getElementById('cv');
      const ctx = cv.getContext('2d');
      const tooltip = document.getElementById('tooltip');
      const ctxMenu = document.getElementById('ctxMenu');
      const toast = document.getElementById('toast');

      const MARGIN = { top: 20, right: 20, bottom: 32, left: 52 };
      const POINT_RADIUS = 5;
      const HANDLE_RADIUS = 3.5;
      const HIT_RADIUS = 10;

      // Control points: {x, y (fractional 0-1), handleIn: {x,y}, handleOut: {x,y}, mode: 'smooth'|'corner'|'auto'}
      let points = [];
      let selected = -1;       // index of selected point
      let dragging = null;     // {type: 'point'|'handleIn'|'handleOut', idx}
      let hovering = null;     // same structure or null
      let playheadFrac = 0;    // 0-1
      let isPlaying = false;
      let playStartTime = 0;
      let playRAF = null;

      // =================================================================
      //  PARAMS
      // =================================================================
      const $ = id => document.getElementById(id);
      function params() {
        return {
          totalTime: parseFloat($('inTime').value) || 3,
          maxAngle: parseFloat($('inAngle').value) || 360,
          dt: parseFloat($('inDt').value) || 0.001,
          stepsPerRev: parseInt($('inSteps').value) || 400,
        };
      }

      // =================================================================
      //  COORDINATE UTILS
      // =================================================================
      function plotArea() {
        const dpr = window.devicePixelRatio || 1;
        return {
          x: MARGIN.left,
          y: MARGIN.top,
          w: cv.width / dpr - MARGIN.left - MARGIN.right,
          h: cv.height / dpr - MARGIN.top - MARGIN.bottom,
        };
      }

      function frac2canvas(fx, fy) {
        const p = plotArea();
        return [p.x + fx * p.w, p.y + (1 - fy) * p.h];
      }

      function canvas2frac(cx, cy) {
        const p = plotArea();
        return [(cx - p.x) / p.w, 1 - (cy - p.y) / p.h];
      }

      function frac2real(fx, fy) {
        const pr = params();
        return { t: fx * pr.totalTime, angle: fy * pr.maxAngle };
      }

      // =================================================================
      //  BÉZIER MATH
      // =================================================================
      function cubicBezier(p0, p1, p2, p3, t) {
        const mt = 1 - t;
        return mt * mt * mt * p0 + 3 * mt * mt * t * p1 + 3 * mt * t * t * p2 + t * t * t * p3;
      }

      function cubicBezierDerivative(p0, p1, p2, p3, t) {
        const mt = 1 - t;
        return 3 * mt * mt * (p1 - p0) + 6 * mt * t * (p2 - p1) + 3 * t * t * (p3 - p2);
      }

      function autoTangent(pts, i) {
        const prev = pts[Math.max(0, i - 1)];
        const curr = pts[i];
        const next = pts[Math.min(pts.length - 1, i + 1)];
        const dx = (next.x - prev.x) * 0.25;
        const dy = (next.y - prev.y) * 0.25;
        curr.handleIn = { x: curr.x - dx, y: curr.y - dy };
        curr.handleOut = { x: curr.x + dx, y: curr.y + dy };
      }

      function sortedPoints() {
        return [...points].sort((a, b) => a.x - b.x);
      }

      // Evaluate the full spline at fractional x (0-1), returns fractional y
      function evalSpline(sorted, fx) {
        if (sorted.length < 2) return sorted.length ? sorted[0].y : 0;
        if (fx <= sorted[0].x) return sorted[0].y;
        if (fx >= sorted[sorted.length - 1].x) return sorted[sorted.length - 1].y;

        for (let i = 0; i < sorted.length - 1; i++) {
          const a = sorted[i], b = sorted[i + 1];
          if (fx >= a.x && fx <= b.x) {
            // Find t for this segment using Newton's method on x
            const segFrac = (b.x - a.x) > 0 ? (fx - a.x) / (b.x - a.x) : 0;
            // Use x coords of bezier control points
            const cp1x = a.handleOut ? a.handleOut.x : a.x + (b.x - a.x) / 3;
            const cp2x = b.handleIn ? b.handleIn.x : b.x - (b.x - a.x) / 3;
            const cp1y = a.handleOut ? a.handleOut.y : a.y + (b.y - a.y) / 3;
            const cp2y = b.handleIn ? b.handleIn.y : b.y - (b.y - a.y) / 3;

            // Approximate t from x using a few Newton iterations
            let t = segFrac;
            for (let iter = 0; iter < 8; iter++) {
              const xAt = cubicBezier(a.x, cp1x, cp2x, b.x, t);
              const dxAt = cubicBezierDerivative(a.x, cp1x, cp2x, b.x, t);
              if (Math.abs(dxAt) < 1e-10) break;
              t -= (xAt - fx) / dxAt;
              t = Math.max(0, Math.min(1, t));
            }

            return cubicBezier(a.y, cp1y, cp2y, b.y, t);
          }
        }
        return sorted[sorted.length - 1].y;
      }

      // =================================================================
      //  DRAWING
      // =================================================================
      function draw() {
        const dpr = window.devicePixelRatio || 1;
        const w = cv.width / dpr, h = cv.height / dpr;
        ctx.clearRect(0, 0, w, h);

        const p = plotArea();
        const pr = params();

        // Background
        ctx.fillStyle = '#1c1c1c';
        ctx.fillRect(p.x, p.y, p.w, p.h);

        drawGrid(p, pr);
        drawAxes(p, pr);

        const sorted = sortedPoints();
        if (sorted.length >= 2) {
          drawBezierCurve(sorted, p);
        }

        // Draw control points & handles
        sorted.forEach((pt, i) => {
          const origIdx = points.indexOf(pt);
          const isSel = origIdx === selected;
          drawPoint(pt, origIdx, isSel, i === 0 || i === sorted.length - 1);
        });

        // Playhead
        if (playheadFrac > 0 || isPlaying) {
          drawPlayhead(sorted, p, pr);
        }

        // Timeline ruler
        drawTimeline(p, pr);

        updateInfo(sorted);
      }

      function drawGrid(p, pr) {
        // Vertical
        const tStep = niceStep(pr.totalTime, p.w, 80);
        for (let t = 0; t <= pr.totalTime + 0.0001; t += tStep) {
          const x = p.x + (t / pr.totalTime) * p.w;
          ctx.strokeStyle = Math.abs(t % (tStep * 5)) < tStep * 0.1 ? 'var(--grid-major)' : 'var(--grid)';
          ctx.lineWidth = 0.5;
          ctx.beginPath(); ctx.moveTo(x, p.y); ctx.lineTo(x, p.y + p.h); ctx.stroke();
        }
        // Horizontal
        const aStep = niceStep(pr.maxAngle, p.h, 60);
        for (let a = 0; a <= pr.maxAngle + 0.0001; a += aStep) {
          const y = p.y + (1 - a / pr.maxAngle) * p.h;
          ctx.strokeStyle = 'var(--grid)';
          ctx.beginPath(); ctx.moveTo(p.x, y); ctx.lineTo(p.x + p.w, y); ctx.stroke();
        }
      }

      function drawAxes(p, pr) {
        ctx.strokeStyle = 'var(--border)';
        ctx.lineWidth = 1;
        // Left
        ctx.beginPath(); ctx.moveTo(p.x, p.y); ctx.lineTo(p.x, p.y + p.h); ctx.stroke();
        // Bottom
        ctx.beginPath(); ctx.moveTo(p.x, p.y + p.h); ctx.lineTo(p.x + p.w, p.y + p.h); ctx.stroke();

        // Angle labels (left)
        ctx.font = '10px Inter, sans-serif';
        ctx.fillStyle = 'var(--text-muted)';
        ctx.textAlign = 'right';
        const aStep = niceStep(pr.maxAngle, p.h, 60);
        for (let a = 0; a <= pr.maxAngle + 0.0001; a += aStep) {
          const y = p.y + (1 - a / pr.maxAngle) * p.h;
          ctx.fillText(a.toFixed(0) + '°', p.x - 6, y + 3);
        }
      }

      function drawTimeline(p, pr) {
        const y = p.y + p.h;
        const tStep = niceStep(pr.totalTime, p.w, 80);

        ctx.font = '10px Inter, sans-serif';
        ctx.fillStyle = 'var(--text-dim)';
        ctx.textAlign = 'center';
        for (let t = 0; t <= pr.totalTime + 0.0001; t += tStep) {
          const x = p.x + (t / pr.totalTime) * p.w;
          // Tick
          ctx.strokeStyle = 'var(--text-muted)';
          ctx.lineWidth = 1;
          ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x, y + 6); ctx.stroke();
          // Label
          ctx.fillText(t.toFixed(1) + 's', x, y + 18);
        }

        // Small ticks between
        const smallStep = tStep / 5;
        ctx.strokeStyle = 'var(--border)';
        ctx.lineWidth = 0.5;
        for (let t = 0; t <= pr.totalTime + 0.0001; t += smallStep) {
          const x = p.x + (t / pr.totalTime) * p.w;
          ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x, y + 3); ctx.stroke();
        }
      }

      function drawBezierCurve(sorted, p) {
        ctx.beginPath();
        const [sx, sy] = frac2canvas(sorted[0].x, sorted[0].y);
        ctx.moveTo(sx, sy);

        for (let i = 0; i < sorted.length - 1; i++) {
          const a = sorted[i], b = sorted[i + 1];
          const cp1x = a.handleOut ? a.handleOut.x : a.x + (b.x - a.x) / 3;
          const cp1y = a.handleOut ? a.handleOut.y : a.y + (b.y - a.y) / 3;
          const cp2x = b.handleIn ? b.handleIn.x : b.x - (b.x - a.x) / 3;
          const cp2y = b.handleIn ? b.handleIn.y : b.y - (b.y - a.y) / 3;

          const [c1x, c1y] = frac2canvas(cp1x, cp1y);
          const [c2x, c2y] = frac2canvas(cp2x, cp2y);
          const [ex, ey] = frac2canvas(b.x, b.y);
          ctx.bezierCurveTo(c1x, c1y, c2x, c2y, ex, ey);
        }

        // Glow
        ctx.strokeStyle = 'var(--curve)';
        ctx.lineWidth = 2;
        ctx.shadowColor = 'var(--curve-glow)';
        ctx.shadowBlur = 10;
        ctx.stroke();
        ctx.shadowBlur = 0;

        // Fill under
        const last = sorted[sorted.length - 1];
        const [lx, ly] = frac2canvas(last.x, last.y);
        ctx.lineTo(lx, p.y + p.h);
        const [fx, fy] = frac2canvas(sorted[0].x, sorted[0].y);
        ctx.lineTo(fx, p.y + p.h);
        ctx.closePath();
        const grad = ctx.createLinearGradient(0, p.y, 0, p.y + p.h);
        grad.addColorStop(0, 'rgba(91,155,213,0.06)');
        grad.addColorStop(1, 'rgba(91,155,213,0.01)');
        ctx.fillStyle = grad;
        ctx.fill();
      }

      function drawPoint(pt, origIdx, isSel, isEndpoint) {
        const [cx, cy] = frac2canvas(pt.x, pt.y);

        // Draw handles if selected
        if (isSel) {
          if (pt.handleIn) {
            const [hx, hy] = frac2canvas(pt.handleIn.x, pt.handleIn.y);
            ctx.strokeStyle = 'var(--handle-line)';
            ctx.lineWidth = 1;
            ctx.beginPath(); ctx.moveTo(cx, cy); ctx.lineTo(hx, hy); ctx.stroke();
            ctx.beginPath(); ctx.arc(hx, hy, HANDLE_RADIUS, 0, Math.PI * 2);
            ctx.fillStyle = 'var(--handle-dot)';
            ctx.fill();
          }
          if (pt.handleOut) {
            const [hx, hy] = frac2canvas(pt.handleOut.x, pt.handleOut.y);
            ctx.strokeStyle = 'var(--handle-line)';
            ctx.lineWidth = 1;
            ctx.beginPath(); ctx.moveTo(cx, cy); ctx.lineTo(hx, hy); ctx.stroke();
            ctx.beginPath(); ctx.arc(hx, hy, HANDLE_RADIUS, 0, Math.PI * 2);
            ctx.fillStyle = 'var(--handle-dot)';
            ctx.fill();
          }
        }

        // Diamond shape
        const r = isSel ? 6 : POINT_RADIUS;
        ctx.save();
        ctx.translate(cx, cy);
        ctx.rotate(Math.PI / 4);
        ctx.beginPath();
        ctx.rect(-r / Math.SQRT2, -r / Math.SQRT2, r * Math.SQRT2, r * Math.SQRT2);
        ctx.fillStyle = isSel ? 'var(--accent)' : (isEndpoint ? '#7a8da6' : 'var(--curve)');
        ctx.fill();
        ctx.strokeStyle = isSel ? '#fff' : 'rgba(255,255,255,0.3)';
        ctx.lineWidth = 1;
        ctx.stroke();
        ctx.restore();
      }

      function drawPlayhead(sorted, p, pr) {
        const x = p.x + playheadFrac * p.w;

        // Vertical line
        ctx.strokeStyle = 'var(--playhead)';
        ctx.lineWidth = 1.5;
        ctx.setLineDash([]);
        ctx.beginPath(); ctx.moveTo(x, p.y); ctx.lineTo(x, p.y + p.h); ctx.stroke();

        // Triangle at top
        ctx.fillStyle = 'var(--playhead)';
        ctx.beginPath();
        ctx.moveTo(x - 5, p.y);
        ctx.lineTo(x + 5, p.y);
        ctx.lineTo(x, p.y + 7);
        ctx.closePath();
        ctx.fill();

        // Current value label
        if (sorted.length >= 2) {
          const yFrac = evalSpline(sorted, playheadFrac);
          const real = frac2real(playheadFrac, yFrac);
          const [px, py] = frac2canvas(playheadFrac, yFrac);

          // Dot on curve
          ctx.beginPath(); ctx.arc(px, py, 4, 0, Math.PI * 2);
          ctx.fillStyle = 'var(--playhead)';
          ctx.fill();

          // Label
          ctx.font = '600 10px Inter, sans-serif';
          ctx.fillStyle = 'var(--playhead)';
          ctx.textAlign = x > p.x + p.w / 2 ? 'right' : 'left';
          const labelX = x > p.x + p.w / 2 ? x - 8 : x + 8;
          ctx.fillText(`${real.angle.toFixed(1)}°`, labelX, py - 8);
        }
      }

      function niceStep(range, pixels, minSpacing) {
        const count = Math.max(1, Math.floor(pixels / minSpacing));
        const raw = range / count;
        const mag = Math.pow(10, Math.floor(Math.log10(raw)));
        const norm = raw / mag;
        const nice = norm <= 1 ? 1 : norm <= 2 ? 2 : norm <= 5 ? 5 : 10;
        return nice * mag;
      }

      function updateInfo(sorted) {
        const pr = params();
        const segs = sorted.length >= 2 ? Math.ceil(pr.totalTime / pr.dt) + 1 : 0;
        $('infoDisplay').textContent = `${sorted.length} pts · ${segs.toLocaleString()} segs`;
      }

      // =================================================================
      //  HIT TESTING
      // =================================================================
      function hitTest(mx, my) {
        for (let i = 0; i < points.length; i++) {
          const pt = points[i];

          // Check handles first (only for selected point)
          if (i === selected) {
            if (pt.handleIn) {
              const [hx, hy] = frac2canvas(pt.handleIn.x, pt.handleIn.y);
              if (Math.hypot(mx - hx, my - hy) < HIT_RADIUS) return { type: 'handleIn', idx: i };
            }
            if (pt.handleOut) {
              const [hx, hy] = frac2canvas(pt.handleOut.x, pt.handleOut.y);
              if (Math.hypot(mx - hx, my - hy) < HIT_RADIUS) return { type: 'handleOut', idx: i };
            }
          }

          // Check point
          const [cx, cy] = frac2canvas(pt.x, pt.y);
          if (Math.hypot(mx - cx, my - cy) < HIT_RADIUS) return { type: 'point', idx: i };
        }
        return null;
      }

      function mousePos(e) {
        const r = cv.getBoundingClientRect();
        return [e.clientX - r.left, e.clientY - r.top];
      }

      // =================================================================
      //  MOUSE EVENTS
      // =================================================================
      cv.addEventListener('mousedown', (e) => {
        if (e.button === 2) return;
        hideCtxMenu();
        const [mx, my] = mousePos(e);
        const hit = hitTest(mx, my);

        if (hit) {
          dragging = hit;
          if (hit.type === 'point') selected = hit.idx;
          cv.style.cursor = 'grabbing';
        } else {
          // Click on timeline ruler to set playhead?
          const p = plotArea();
          if (my > p.y + p.h && my < p.y + p.h + 30) {
            playheadFrac = Math.max(0, Math.min(1, (mx - p.x) / p.w));
            draw();
            return;
          }

          // Add new point on canvas
          if (mx >= p.x && mx <= p.x + p.w && my >= p.y && my <= p.y + p.h) {
            const [fx, fy] = canvas2frac(mx, my);
            const clampedX = Math.max(0, Math.min(1, fx));
            const clampedY = Math.max(0, Math.min(1, fy));
            const newPt = { x: clampedX, y: clampedY, handleIn: null, handleOut: null, mode: 'auto' };
            points.push(newPt);

            // Recalculate auto tangents for all auto-mode points
            const sorted = sortedPoints();
            sorted.forEach((pt, i) => { if (pt.mode === 'auto') autoTangent(sorted, i); });

            selected = points.length - 1;
            dragging = { type: 'point', idx: selected };
            cv.style.cursor = 'grabbing';
            draw();
          } else {
            selected = -1;
            draw();
          }
        }
      });

      cv.addEventListener('mousemove', (e) => {
        const [mx, my] = mousePos(e);

        if (dragging) {
          const [fx, fy] = canvas2frac(mx, my);
          const pt = points[dragging.idx];

          if (dragging.type === 'point') {
            const dx = Math.max(0, Math.min(1, fx)) - pt.x;
            const dy = Math.max(0, Math.min(1, fy)) - pt.y;
            pt.x = Math.max(0, Math.min(1, fx));
            pt.y = Math.max(0, Math.min(1, fy));
            // Move handles with point
            if (pt.handleIn) { pt.handleIn.x += dx; pt.handleIn.y += dy; }
            if (pt.handleOut) { pt.handleOut.x += dx; pt.handleOut.y += dy; }
          } else if (dragging.type === 'handleOut') {
            pt.handleOut = { x: fx, y: fy };
            if (pt.mode === 'smooth' && pt.handleIn) {
              // Mirror handle
              const dx = fx - pt.x, dy = fy - pt.y;
              const len = Math.hypot(pt.handleIn.x - pt.x, pt.handleIn.y - pt.y);
              const dist = Math.hypot(dx, dy) || 1;
              pt.handleIn = { x: pt.x - dx / dist * len, y: pt.y - dy / dist * len };
            }
          } else if (dragging.type === 'handleIn') {
            pt.handleIn = { x: fx, y: fy };
            if (pt.mode === 'smooth' && pt.handleOut) {
              const dx = fx - pt.x, dy = fy - pt.y;
              const len = Math.hypot(pt.handleOut.x - pt.x, pt.handleOut.y - pt.y);
              const dist = Math.hypot(dx, dy) || 1;
              pt.handleOut = { x: pt.x - dx / dist * len, y: pt.y - dy / dist * len };
            }
          }

          draw();
          showTooltipForPoint(pt, mx, my);
          return;
        }

        // Hover
        const hit = hitTest(mx, my);
        hovering = hit;
        const p = plotArea();

        if (hit) {
          cv.style.cursor = 'grab';
          showTooltipForPoint(points[hit.idx], mx, my);
        } else if (my > p.y + p.h && my < p.y + p.h + 30) {
          cv.style.cursor = 'pointer';
          tooltip.style.display = 'none';
        } else if (mx >= p.x && mx <= p.x + p.w && my >= p.y && my <= p.y + p.h) {
          cv.style.cursor = 'crosshair';
          // Show coords tooltip
          const [fx, fy] = canvas2frac(mx, my);
          if (fx >= 0 && fx <= 1 && fy >= 0 && fy <= 1) {
            const rr = frac2real(fx, fy);
            tooltip.textContent = `${rr.t.toFixed(3)}s  ${rr.angle.toFixed(1)}°`;
            tooltip.style.display = 'block';
            tooltip.style.left = (e.clientX + 14) + 'px';
            tooltip.style.top = (e.clientY - 8) + 'px';
          }
        } else {
          cv.style.cursor = 'default';
          tooltip.style.display = 'none';
        }
      });

      function showTooltipForPoint(pt, mx, my) {
        const real = frac2real(pt.x, pt.y);
        tooltip.textContent = `t=${real.t.toFixed(3)}s  θ=${real.angle.toFixed(1)}°`;
        tooltip.style.display = 'block';
        const r = cv.getBoundingClientRect();
        tooltip.style.left = (r.left + mx + 14) + 'px';
        tooltip.style.top = (r.top + my - 8) + 'px';
      }

      cv.addEventListener('mouseup', () => {
        if (dragging && dragging.type === 'point') {
          // Recalc auto tangents
          const sorted = sortedPoints();
          sorted.forEach((pt, i) => { if (pt.mode === 'auto') autoTangent(sorted, i); });
          draw();
        }
        dragging = null;
        cv.style.cursor = 'crosshair';
      });

      cv.addEventListener('mouseleave', () => {
        dragging = null;
        hovering = null;
        tooltip.style.display = 'none';
        cv.style.cursor = 'crosshair';
      });

      // Right-click context menu
      cv.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        const [mx, my] = mousePos(e);
        const hit = hitTest(mx, my);
        if (hit && hit.type === 'point') {
          selected = hit.idx;
          draw();
          ctxMenu.style.display = 'block';
          ctxMenu.style.left = e.clientX + 'px';
          ctxMenu.style.top = e.clientY + 'px';
        }
      });

      function hideCtxMenu() { ctxMenu.style.display = 'none'; }
      document.addEventListener('click', hideCtxMenu);

      ctxMenu.querySelectorAll('.ctx-item').forEach(item => {
        item.addEventListener('click', () => {
          const action = item.dataset.action;
          if (selected < 0 || selected >= points.length) return;
          const pt = points[selected];

          if (action === 'delete') {
            points.splice(selected, 1);
            selected = -1;
            const sorted = sortedPoints();
            sorted.forEach((p, i) => { if (p.mode === 'auto') autoTangent(sorted, i); });
          } else if (action === 'smooth') {
            pt.mode = 'smooth';
          } else if (action === 'corner') {
            pt.mode = 'corner';
          } else if (action === 'auto') {
            pt.mode = 'auto';
            const sorted = sortedPoints();
            const si = sorted.indexOf(pt);
            if (si >= 0) autoTangent(sorted, si);
          }
          hideCtxMenu();
          draw();
        });
      });

      // =================================================================
      //  KEYBOARD
      // =================================================================
      document.addEventListener('keydown', (e) => {
        if (e.target.tagName === 'INPUT') return;

        if (e.key === ' ' || e.key === 'Space') {
          e.preventDefault();
          togglePlay();
        } else if ((e.key === 'Delete' || e.key === 'Backspace') && selected >= 0) {
          points.splice(selected, 1);
          selected = -1;
          const sorted = sortedPoints();
          sorted.forEach((p, i) => { if (p.mode === 'auto') autoTangent(sorted, i); });
          draw();
        } else if (e.key === 's' && selected >= 0) {
          points[selected].mode = 'smooth';
          draw();
        } else if (e.key === 'c' && selected >= 0) {
          points[selected].mode = 'corner';
          draw();
        } else if (e.key === 'a' && selected >= 0) {
          points[selected].mode = 'auto';
          const sorted = sortedPoints();
          const si = sorted.indexOf(points[selected]);
          if (si >= 0) autoTangent(sorted, si);
          draw();
        }
      });

      // =================================================================
      //  PLAYBACK
      // =================================================================
      function togglePlay() {
        if (isPlaying) {
          stopPlay();
        } else {
          startPlay();
        }
      }

      function startPlay() {
        if (sortedPoints().length < 2) { showToastMsg('Need at least 2 points', true); return; }
        isPlaying = true;
        playheadFrac = 0;
        playStartTime = performance.now();
        $('btnPlay').textContent = '■';
        $('btnPlay').classList.add('playing');
        playLoop();
      }

      function stopPlay() {
        isPlaying = false;
        if (playRAF) cancelAnimationFrame(playRAF);
        playRAF = null;
        $('btnPlay').textContent = '▶';
        $('btnPlay').classList.remove('playing');
        draw();
      }

      function playLoop() {
        if (!isPlaying) return;
        const pr = params();
        const elapsed = (performance.now() - playStartTime) / 1000;
        playheadFrac = elapsed / pr.totalTime;

        if (playheadFrac >= 1) {
          playheadFrac = 1;
          draw();
          stopPlay();
          return;
        }

        draw();
        playRAF = requestAnimationFrame(playLoop);
      }

      // =================================================================
      //  TRAJECTORY GENERATION
      // =================================================================
      function generateTrajectory() {
        const pr = params();
        const sorted = sortedPoints();
        if (sorted.length < 2) return [];

        const trajectory = [];
        for (let t = 0; t <= pr.totalTime + pr.dt * 0.5; t += pr.dt) {
          const frac = t / pr.totalTime;
          const yFrac = evalSpline(sorted, frac);
          const angleDeg = yFrac * pr.maxAngle;
          const steps = Math.round((angleDeg / 360) * pr.stepsPerRev);
          trajectory.push([parseFloat(t.toFixed(6)), steps]);
        }

        // Snap final point
        const lastPt = sorted[sorted.length - 1];
        const finalSteps = Math.round((lastPt.y * pr.maxAngle / 360) * pr.stepsPerRev);
        if (trajectory.length > 0) trajectory[trajectory.length - 1][1] = finalSteps;

        return trajectory;
      }

      // =================================================================
      //  BUTTONS
      // =================================================================
      $('btnPlay').addEventListener('click', togglePlay);

      $('btnSend').addEventListener('click', async () => {
        const trajectory = generateTrajectory();
        if (!trajectory.length) { showToastMsg('Add at least 2 points', true); return; }

        const serverUrl = (location.protocol === 'http:' || location.protocol === 'https:')
          ? location.origin + '/trajectory'
          : 'http://127.0.0.1:8742/trajectory';

        try {
          const resp = await fetch(serverUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(trajectory),
          });
          if (!resp.ok) {
            const err = await resp.json().catch(() => ({}));
            throw new Error(err.message || `Server returned ${resp.status}`);
          }
          const result = await resp.json();
          showToastMsg(`Sent ${result.points.toLocaleString()} pts → Pi`);
          $('btnSend').disabled = true;
          $('btnSend').textContent = '✓ Sent';
          setTimeout(() => { $('btnSend').disabled = false; $('btnSend').textContent = '▶ Send to Motor'; }, 3000);
        } catch (err) {
          showToastMsg(err.message, true);
        }
      });

      $('btnClear').addEventListener('click', () => {
        points = [];
        selected = -1;
        dragging = null;
        playheadFrac = 0;
        draw();
      });

      $('btnPreset').addEventListener('click', () => {
        points = [
          { x: 0, y: 0, handleIn: null, handleOut: { x: 0.11, y: 0 }, mode: 'smooth' },
          { x: 1 / 3, y: 1 / 3, handleIn: { x: 0.22, y: 1 / 3 }, handleOut: { x: 0.44, y: 1 / 3 }, mode: 'smooth' },
          { x: 2 / 3, y: 2 / 3, handleIn: { x: 0.56, y: 2 / 3 }, handleOut: { x: 0.78, y: 2 / 3 }, mode: 'smooth' },
          { x: 1, y: 1, handleIn: { x: 0.89, y: 1 }, handleOut: null, mode: 'smooth' },
        ];
        selected = -1;
        draw();
        showToastMsg('Loaded trapezoid preset');
      });

      $('btnSCurve').addEventListener('click', () => {
        points = [
          { x: 0, y: 0, handleIn: null, handleOut: { x: 0.35, y: 0 }, mode: 'smooth' },
          { x: 1, y: 1, handleIn: { x: 0.65, y: 1 }, handleOut: null, mode: 'smooth' },
        ];
        selected = -1;
        draw();
        showToastMsg('Loaded S-curve preset');
      });

      // Param changes
      [$('inTime'), $('inAngle'), $('inDt'), $('inSteps')].forEach(el =>
        el.addEventListener('input', () => draw())
      );

      // =================================================================
      //  TOAST
      // =================================================================
      function showToastMsg(msg, isErr = false) {
        toast.textContent = msg;
        toast.className = 'toast' + (isErr ? ' error' : '') + ' show';
        setTimeout(() => toast.classList.remove('show'), 2500);
      }

      // =================================================================
      //  RESIZE & INIT
      // =================================================================
      function resize() {
        const wrap = cv.parentElement;
        const dpr = window.devicePixelRatio || 1;
        cv.width = wrap.clientWidth * dpr;
        cv.height = wrap.clientHeight * dpr;
        cv.style.width = wrap.clientWidth + 'px';
        cv.style.height = wrap.clientHeight + 'px';
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        draw();
      }

      window.addEventListener('resize', resize);

      // Default: S-curve
      points = [
        { x: 0, y: 0, handleIn: null, handleOut: { x: 0.35, y: 0 }, mode: 'smooth' },
        { x: 1, y: 1, handleIn: { x: 0.65, y: 1 }, handleOut: null, mode: 'smooth' },
      ];

      resize();
    })();
  </script>
</body>

</html>